### å…¨å±€æœç´¢
>
> éœ€è¦åº•å±‚ä¿®æ”¹ç¬¬ä¸‰æ–¹è™šæ‹Ÿåˆ—è¡¨ä»£ç èƒ½å¤Ÿå®ç°
>

#### å¿«æ·é”®åŠ«æŒ

```tsx
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // å¤„ç† Ctrl+F
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æµè§ˆå™¨æœç´¢
        setSearchVisible(true);
      }
      // å¤„ç† Escape
      if (e.key === 'Escape') {
        setSearchVisible(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
```

#### æœç´¢

```tsx
  const findMatches = useCallback((text: string) => {
    if (!text.trim()) {
      setSearchMatches([]);
      setCurrentMatchIndex(0);
      return;
    }

    const matches: Array<{ rowIndex: number; columnKey: string; matchIndex: number }> = [];
    let matchIndex = 0;

    dataSource.forEach((record, rowIndex) => {
      // æœç´¢IDåˆ—
      if (record.id?.toString().toLowerCase().includes(text.toLowerCase())) {
        matches.push({ rowIndex, columnKey: 'id', matchIndex: matchIndex++ });
      }

      // æœç´¢æ•°æ®åˆ—
      for (let i = 1; i <= 20; i++) {
        const columnKey = `col${i}`;
        const value = (record as any)[columnKey];
        if (value && value.toString().toLowerCase().includes(text.toLowerCase())) {
          matches.push({ rowIndex, columnKey, matchIndex: matchIndex++ });
        }
      }
    });

    console.log(`ğŸ” æœç´¢"${text}"æ‰¾åˆ° ${matches.length} ä¸ªåŒ¹é…é¡¹:`, matches.map(m => `è¡Œ${m.rowIndex + 1}:${m.columnKey}`));
    setSearchMatches(matches);
    setCurrentMatchIndex(0);
    
    // å¦‚æœæ‰¾åˆ°åŒ¹é…é¡¹ï¼Œç«‹å³æ»šåŠ¨åˆ°ç¬¬ä¸€ä¸ª
    if (matches.length > 0) {
      setTimeout(() => {
        scrollToMatch(matches[0]);
      }, 50);
    }
  }, [dataSource, scrollToMatch]);
```

#### è™šæ‹Ÿåˆ—è¡¨æŒ‡å®šè¡Œåˆ—è·³è½¬

```tsx
/**
   * å®šä½æ»šåŠ¨æ¡
   * @desc ä¼˜å…ˆçº§æŒ‰å‚æ•°é¡ºåºé™åº
   * @param top ç›®æ ‡å€¼
   * @param element ç›®æ ‡å…ƒç´ 
   * @param rowKey è¡Œä¸»é”®
   * @param rowIndex è¡Œç´¢å¼•
   * @param offset çºµå‘æ»šåŠ¨åç§»é‡ï¼Œç”¨äºæŠµæ¶ˆå›ºå®šè¡¨å¤´
   */
  scrollTo({
    top,
    element,
    rowKey,
    rowIndex,
    offset,
  }: {
    element: HTMLElement
    top: number
    rowKey: string
    rowIndex: number
    offset: number
  }) {
    if (top > -1) return this.scrollToValue(top)
    if (element) return this.scrollToElement(element, offset)
    if (rowKey) return this.scrollToRowKey(rowKey, offset)
    if (rowIndex) return this.scrollToRowIndex(rowIndex, offset)
  }

  /**
   * å®šä½åˆ°æŒ‡å®šä½ç½®
   * @desc åŠ¨æ€è¡Œé«˜æ—¶å¦‚éœ€ç²¾å‡†å®šä½ï¼Œå¯ä»¥ä¼ å…¥ç›®æ ‡å…ƒç´ è¿›è¡ŒäºŒæ¬¡ä¿®æ­£
   * @param top çºµå‘æ»šåŠ¨æ¡ä½ç½®
   * @param selector ç›®æ ‡å…ƒç´ é€‰æ‹©å™¨
   * @param offset çºµå‘æ»šåŠ¨åç§»é‡ï¼Œç”¨äºæŠµæ¶ˆå›ºå®šè¡¨å¤´
   */
  private scrollToValue(top: number, selector?: string, offset?: number) {
    let view = this.artTableWrapperRef.current
    if (view.clientHeight === view.scrollHeight) {
      view = document.documentElement as HTMLDivElement
    }
    if (!selector) {
      return (view.scrollTop = top)
    }
    const element = view.querySelector(selector)
    // ç›®æ ‡å…ƒç´ çœŸå®å­˜åœ¨æ—¶ç›´æ¥ç²¾å‡†å®šä½
    if (element) {
      return this.scrollToElement(element, offset)
    }
    view.scrollTop = top
    // å»¶è¿Ÿä¿®æ­£
    setTimeout(() => {
      this.scrollToElement(view.querySelector(selector), offset)
    }, 16)
  }

  /**
   * å®šä½åˆ°æŒ‡å®šå…ƒç´ 
   * @desc è™šæ‹Ÿè¡¨æ ¼ä¸åº”è¯¥ç›´æ¥ä½¿ç”¨è¯¥æ–¹æ³•
   * @param element
   * @param offset çºµå‘æ»šåŠ¨åç§»é‡ï¼Œç”¨äºæŠµæ¶ˆå›ºå®šè¡¨å¤´
   */
  private scrollToElement(element: Element, offset?: number) {
    if (!element) return
    let view = this.artTableWrapperRef.current
    if (view.clientHeight === view.scrollHeight) {
      view = document.documentElement as HTMLDivElement
    }
    view.scrollTop = this.getScrollOffsetTop(element, view) + (offset || 0)
  }

  /**
   * å®šä½åˆ°æŒ‡å®šè¡Œ
   * @desc æ ‘å½¢è¡¨æ ¼æœ‰èŠ‚ç‚¹å±•å¼€æ—¶ä¸åº”è¯¥ä½¿ç”¨æ­¤æ–¹æ³•
   * @param rowIndex è¡Œå·ï¼ˆä»1å¼€å§‹ï¼‰
   * @param offset çºµå‘æ»šåŠ¨åç§»é‡ï¼Œç”¨äºæŠµæ¶ˆå›ºå®šè¡¨å¤´
   */
  private scrollToRowIndex(rowIndex: number, offset?: number) {
    const { cache } = this.rowHeightManager
    const end = Math.min(rowIndex + 1, cache.length)
    let scrollTop = 0
    for (let i = 0; i < end; i++) {
      scrollTop += cache[i]
    }
    this.scrollToValue(scrollTop, `[data-rowindex="${rowIndex}"]`, offset)
  }

  /**
   * æ ¹æ®primaryKeyå®šä½åˆ°æŒ‡å®šè¡Œ
   * @desc æ”¯æŒåœ¨æ ‘å‹è¡¨æ ¼ä¸­å®šä½åˆ°æœªå±•å¼€çš„èŠ‚ç‚¹ï¼Œè°ƒç”¨æ—¶åº”æå‰æ›´æ–°è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰çˆ¶èŠ‚ç‚¹keyè‡³openKeysä¸­ï¼Œå¹¶å»¶è¿Ÿè°ƒç”¨è¯¥æ–¹æ³•ï¼‰
   * @param rowKey è¡Œä¸»é”®
   * @param offset çºµå‘æ»šåŠ¨åç§»é‡ï¼Œç”¨äºæŠµæ¶ˆå›ºå®šè¡¨å¤´
   */
  private scrollToRowKey(rowKey: string, offset?: number) {
    const { dataSource } = this.props
    const { cache } = this.rowHeightManager
    const length = dataSource.length
    const { primaryKey } = this.props
    let scrollTop = 0
    for (let i = 1; i < length; i++) {
      scrollTop += cache[i]
      if (dataSource[i][primaryKey as string] === rowKey) break
    }
    this.scrollToValue(scrollTop, `#art-table-row-${rowKey}`, offset)
  }

  /**
   * è·å–å…ƒç´ åœ¨æ»šåŠ¨åŒºåŸŸä¸­çš„ä½ç½®
   * @desc èŠ‚é€‰è‡ªï¼šhttps://github.com/Stanko/animated-scroll-to
   * @param element ç›®æ ‡å…ƒç´ 
   * @param view æ»šåŠ¨åŒºåŸŸå…ƒç´ 
   * @private
   */
  private getScrollOffsetTop(element: Element, view: Element): number {
    return this.getElementOffset(element).top - this.getElementOffset(view).top
  }

  private getScrollOffsetLeft(element: Element, view: Element): number {
    return this.getElementOffset(element).left - this.getElementOffset(view).left
  }

  private getElementOffset(element: any) {
    let top = 0
    let left = 0
    do {
      top += element.offsetTop || 0
      left += element.offsetLeft || 0
      element = element.offsetParent
    } while (element)
    return { top, left }
  }

```

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751871907055-525be7e6-3f86-4dae-9eca-7a8bcfdfa679.png)

### æ‰“å°
>
> å…³é”®è¯ï¼špdfã€å›¾ç‰‡ç¼“å­˜ã€indexDBã€web workerã€å†…å­˜é™åˆ¶ã€åˆ†é¡µåˆ†æ®µå¤„ç†ç­‰
>
> æ³¨æ„ç‚¹ï¼šä½¿ç”¨ pdfkit éœ€è¦è€ƒè™‘å­—ä½“ä»¥åŠæ ·å¼ï¼ˆå·¥ç¨‹é‡å·¨å¤§ï¼Œéœ€è¦ç»˜åˆ¶æ¯ä¸ªæ•°æ®ï¼Œdemo åªæ˜¯ç®€å•ç»˜åˆ¶è¡¨æ ¼éƒ¨åˆ†åœºæ™¯ï¼Œå…·ä½“éœ€è¦æ ¹æ®ä¸šåŠ¡åœºæ™¯è‡ªå·±ç»˜åˆ¶ï¼‰
>

#### æŒ‡å®šæ–‡ä»¶

```tsx
  const fileHandle = await window.showSaveFilePicker({
        suggestedName: `è¡¨æ ¼å¯¼å‡º_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.pdf`,
        types: [{
          description: 'PDFæ–‡ä»¶',
          accept: {
            'application/pdf': ['.pdf'],
          },
        }],
      });

  // è·å–å¯å†™æµ
  writableRef.current = await fileHandle.createWritable();
  
  // å‡†å¤‡åˆ—å®½é…ç½®
  const pageWidth = 750; // A4 æ¨ªå‘çº¸å¼ å®½åº¦
  const columnWidths = {
    groupId: pageWidth * 0.08,
    id: pageWidth * 0.05,
    avatar: pageWidth * 0.1,
    name: pageWidth * 0.1,
    email: pageWidth * 0.17,
    phone: pageWidth * 0.15,
    address: pageWidth * 0.25,
    status: pageWidth * 0.1
  };
  
  // å‘é€æ•°æ®åˆ° Worker
  workerRef.current?.postMessage({
    type: 'generate',
    data: {
      data: dataSourceRef.current,
      columnWidths,
      pageWidth,
      pageHeight: 550 // A4 æ¨ªå‘çº¸å¼ é«˜åº¦
    }
  });
```

#### indexDBç¼“å­˜å›¾ç‰‡

```typescript
/**
 * IndexedDB å›¾ç‰‡ç¼“å­˜æœåŠ¡
 * è§£å†³å¤§æ•°æ®é‡å›¾ç‰‡å¤„ç†çš„å†…å­˜é—®é¢˜
 */

export interface CacheItem {
  url: string;
  buffer: ArrayBuffer;
  timestamp: number;
  accessCount: number;
  lastAccess: number;
}

export class ImageCacheService {
  private dbName = 'pdf-image-cache';
  private storeName = 'images';
  private version = 1;
  private db: IDBDatabase | null = null;
  private maxCacheSize = 1000; // æœ€å¤§ç¼“å­˜æ¡ç›®æ•°
  private maxAge = 24 * 60 * 60 * 1000; // 24å°æ—¶è¿‡æœŸ

  /**
   * åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
   */
  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // åˆ›å»ºå¯¹è±¡å­˜å‚¨
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'url' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('lastAccess', 'lastAccess', { unique: false });
        }
      };
    });
  }

  /**
   * ç¡®ä¿æ•°æ®åº“å·²åˆå§‹åŒ–
   */
  private async ensureDB(): Promise<IDBDatabase> {
    if (!this.db) {
      await this.init();
    }
    return this.db!;
  }

  /**
   * å­˜å‚¨å›¾ç‰‡åˆ° IndexedDB
   */
  async storeImage(url: string, buffer: Buffer): Promise<void> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);

    // ç¡®ä¿è½¬æ¢ä¸º ArrayBuffer
    let arrayBuffer: ArrayBuffer;
    if (buffer.buffer instanceof ArrayBuffer) {
      arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    } else {
      // å¤„ç† SharedArrayBuffer çš„æƒ…å†µ
      const uint8Array = new Uint8Array(buffer);
      arrayBuffer = uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);
    }

    const cacheItem: CacheItem = {
      url,
      buffer: arrayBuffer,
      timestamp: Date.now(),
      accessCount: 1,
      lastAccess: Date.now()
    };

    return new Promise((resolve, reject) => {
      const request = store.put(cacheItem);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * ä» IndexedDB è·å–å›¾ç‰‡
   */
  async getImage(url: string): Promise<Buffer | null> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve, reject) => {
      const request = store.get(url);

      request.onsuccess = () => {
        const result = request.result as CacheItem;
        if (result) {
          // æ›´æ–°è®¿é—®ç»Ÿè®¡
          result.accessCount++;
          result.lastAccess = Date.now();
          store.put(result);
          
          // è½¬æ¢å› Buffer
          const buffer = Buffer.from(result.buffer);
          resolve(buffer);
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å­˜åœ¨äºç¼“å­˜ä¸­
   */
  async hasImage(url: string): Promise<boolean> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readonly');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.count(url);
      request.onsuccess = () => resolve(request.result > 0);
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * æ‰¹é‡é¢„åŠ è½½å›¾ç‰‡
   */
  async preloadBatch(urls: string[]): Promise<void> {
    const loadPromises = urls.map(async (url) => {
      try {
        // æ£€æŸ¥æ˜¯å¦å·²ç¼“å­˜
        const exists = await this.hasImage(url);
        if (exists) return;
        
        // ä¸‹è½½å¹¶ç¼“å­˜å›¾ç‰‡
        const response = await fetch(url);
        if (response.ok) {
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          await this.storeImage(url, buffer);
        }
      } catch (error) {
        console.warn(`é¢„åŠ è½½å›¾ç‰‡å¤±è´¥: ${url}`, error);
      }
    });
    
    await Promise.allSettled(loadPromises);
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   */
  async getCacheStats(): Promise<{ count: number; size: number }> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readonly');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = () => {
        const items = request.result as CacheItem[];
        const count = items.length;
        const size = items.reduce((total, item) => total + item.buffer.byteLength, 0);
        resolve({ count, size });
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆLRUç­–ç•¥ï¼‰
   */
  async cleanupExpiredCache(batchSize: number = 50): Promise<number> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = async () => {
        const items = request.result as CacheItem[];
        const now = Date.now();
        let deletedCount = 0;
        
        // æ‰¾å‡ºéœ€è¦åˆ é™¤çš„é¡¹ç›®
        const toDelete: string[] = [];
        
        // 1. åˆ é™¤è¿‡æœŸé¡¹ç›®
        items.forEach(item => {
          if (now - item.timestamp > this.maxAge) {
            toDelete.push(item.url);
          }
        });
        
        // 2. å¦‚æœç¼“å­˜æ•°é‡è¶…è¿‡é™åˆ¶ï¼Œåˆ é™¤æœ€å°‘ä½¿ç”¨çš„é¡¹ç›®
        if (items.length > this.maxCacheSize) {
          const sortedItems = items
            .filter(item => !toDelete.includes(item.url))
            .sort((a, b) => {
              // æŒ‰æœ€åè®¿é—®æ—¶é—´å’Œè®¿é—®æ¬¡æ•°æ’åºï¼ˆLRUï¼‰
              const scoreA = a.lastAccess + (a.accessCount * 1000);
              const scoreB = b.lastAccess + (b.accessCount * 1000);
              return scoreA - scoreB;
            });
          
          const excessCount = items.length - this.maxCacheSize;
          for (let i = 0; i < Math.min(excessCount, batchSize); i++) {
            toDelete.push(sortedItems[i].url);
          }
        }
        
        // æ‰§è¡Œåˆ é™¤
        const deletePromises = toDelete.map(url => {
          return new Promise<void>((resolveDelete) => {
            const deleteRequest = store.delete(url);
            deleteRequest.onsuccess = () => {
              deletedCount++;
              resolveDelete();
            };
            deleteRequest.onerror = () => resolveDelete();
          });
        });
        
        await Promise.all(deletePromises);
        resolve(deletedCount);
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  async clearAll(): Promise<void> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * å…³é—­æ•°æ®åº“è¿æ¥
   */
  close(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
}

// å•ä¾‹å®ä¾‹
export const imageCacheService = new ImageCacheService();
```

#### ç»˜åˆ¶ pdf ä¸æµå¼å†™å…¥

```typescript
// ç”Ÿæˆ PDF çš„æ ¸å¿ƒé€»è¾‘
async function generatePDF(options: PDFGenerationOptions) {
  try {
    console.log('å¼€å§‹ç”Ÿæˆ PDF...');
    const { data, columnWidths, pageWidth, pageHeight } = options;

    // åˆå§‹åŒ–å›¾ç‰‡ç¼“å­˜æœåŠ¡
    try {
      await imageCacheService.init();
      // æ¸…ç†è¿‡æœŸç¼“å­˜
      await imageCacheService.cleanupExpiredCache();
      console.log('å›¾ç‰‡ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å®Œæˆ');
    } catch (cacheError) {
      console.warn('å›¾ç‰‡ç¼“å­˜æœåŠ¡åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨å†…å­˜ç¼“å­˜:', cacheError);
    }

    // åŠ è½½ PDFKit
    await loadPDFKit();

    // åŠ è½½å­—ä½“
    const fontData = await loadFont();

    // åˆ›å»º PDF æ–‡æ¡£ï¼ˆä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼‰
    const doc = new (self as any).PDFDocument({
      size: 'A4',
      layout: 'landscape',
      margins: { top: 50, left: 50, right: 50, bottom: 50 },
      bufferPages: false, // å…³é—­é¡µé¢ç¼“å­˜ä»¥èŠ‚çœå†…å­˜
      autoFirstPage: false,
      compress: true, // å¯ç”¨å‹ç¼©
      info: {
        Title: 'æ•°æ®å¯¼å‡ºæŠ¥å‘Š',
        Author: 'ç³»ç»Ÿç”Ÿæˆ',
        Subject: 'è¡¨æ ¼æ•°æ®å¯¼å‡º',
        Keywords: 'PDF,Export,Table',
        CreationDate: new Date()
      }
    });

    // æ·»åŠ ç¬¬ä¸€é¡µï¼ˆåœ¨å­—ä½“æµ‹è¯•å‰ç¡®ä¿é¡µé¢å­˜åœ¨ï¼‰
    doc.addPage();
    console.log('æ·»åŠ ç¬¬ä¸€é¡µ');

    // å¼ºåˆ¶ç­‰å¾…ç¡®ä¿æ–‡æ¡£å‡†å¤‡å°±ç»ª
    await new Promise(resolve => setTimeout(resolve, 100));

    // æ³¨å†Œå¹¶ä½¿ç”¨æ€æºé»‘ä½“ï¼ˆæ”¯æŒä¸­æ–‡ï¼‰
    let fontName = 'Helvetica'; // é»˜è®¤å­—ä½“
    let supportsChinese = false;

    if (fontData.byteLength > 0) {
      try {
        console.log('æ³¨å†Œæ€æºé»‘ä½“...');
        doc.registerFont('SourceHanSans', fontData);
        fontName = 'SourceHanSans';
        supportsChinese = true;
        console.log('æ€æºé»‘ä½“æ³¨å†Œå®Œæˆï¼Œæ”¯æŒä¸­æ–‡æ˜¾ç¤º');

        // æµ‹è¯•å­—ä½“æ˜¯å¦çœŸæ­£å¯ç”¨ï¼ˆç¡®ä¿é¡µé¢å·²å­˜åœ¨ï¼‰
        try {
          if (doc.page && doc.page.width) {
            doc.font(fontName).fontSize(12).text('æµ‹è¯•ä¸­æ–‡', 50, 50);
            console.log('ä¸­æ–‡å­—ä½“æµ‹è¯•æˆåŠŸ');
          } else {
            throw new Error('é¡µé¢æœªæ­£ç¡®åˆå§‹åŒ–');
          }
        } catch (testError) {
          console.warn('ä¸­æ–‡å­—ä½“æµ‹è¯•å¤±è´¥ï¼Œå›é€€åˆ°é»˜è®¤å­—ä½“:', testError);
          fontName = 'Helvetica';
          supportsChinese = false;
        }
      } catch (error) {
        console.error('å­—ä½“æ³¨å†Œå¤±è´¥:', error);
        console.warn('å°†ä½¿ç”¨é»˜è®¤å­—ä½“ï¼Œä¸­æ–‡å¯èƒ½æ˜¾ç¤ºä¸ºä¹±ç ');

        // å°è¯•ä½¿ç”¨ç³»ç»Ÿä¸­æ–‡å­—ä½“
        const systemFonts = ['SimSun', 'Microsoft YaHei', 'PingFang SC', 'Hiragino Sans GB', 'STHeiti'];
        for (const sysFont of systemFonts) {
          try {
            if (doc.page && doc.page.width) {
              doc.font(sysFont).fontSize(12).text('æµ‹è¯•', 50, 50);
              fontName = sysFont;
              supportsChinese = true;
              console.log(`ä½¿ç”¨ç³»ç»Ÿå­—ä½“: ${sysFont}`);
              break;
            }
          } catch (sysError) {
            console.warn(`ç³»ç»Ÿå­—ä½“ ${sysFont} ä¸å¯ç”¨:`, sysError);
          }
        }
      }
    } else {
      console.warn('æ€æºé»‘ä½“åŠ è½½å¤±è´¥ï¼Œå°è¯•ç³»ç»Ÿå­—ä½“');

      // å°è¯•ä½¿ç”¨ç³»ç»Ÿä¸­æ–‡å­—ä½“
      const systemFonts = ['SimSun', 'Microsoft YaHei', 'PingFang SC', 'Hiragino Sans GB', 'STHeiti', 'Arial Unicode MS'];
      for (const sysFont of systemFonts) {
        try {
          if (doc.page && doc.page.width) {
            doc.font(sysFont).fontSize(12).text('æµ‹è¯•', 50, 50);
            fontName = sysFont;
            supportsChinese = true;
            console.log(`ä½¿ç”¨ç³»ç»Ÿå­—ä½“: ${sysFont}`);
            break;
          }
        } catch (sysError) {
          console.warn(`ç³»ç»Ÿå­—ä½“ ${sysFont} ä¸å¯ç”¨:`, sysError);
        }
      }
    }

    // æ”¶é›†æ•°æ®å—
    const chunks: Uint8Array[] = [];
    let totalSize = 0;

    doc.on('data', (chunk: Uint8Array) => {
      chunks.push(chunk);
      totalSize += chunk.length;

      if (totalSize >= CHUNK_SIZE) {
        const data = new Uint8Array(Buffer.concat(chunks));
        self.postMessage({
          type: 'progress',
          totalBytes: totalSize,
          chunk: data
        });
        chunks.length = 0;
        totalSize = 0;
      }
    });

    doc.on('end', () => {
      if (chunks.length > 0) {
        const data = new Uint8Array(Buffer.concat(chunks));
        self.postMessage({
          type: 'progress',
          totalBytes: totalSize + data.length,
          chunk: data
        });
      }
      console.log('PDF ç”Ÿæˆå®Œæˆ');
      self.postMessage({ type: 'complete' });
    });

    // æ£€æŸ¥æ–‡æ¡£çŠ¶æ€
    console.log('æ£€æŸ¥æ–‡æ¡£çŠ¶æ€:');
    console.log('- é¡µé¢æ•°é‡:', doc.bufferedPageRange ? doc.bufferedPageRange().count : 'unknown');
    console.log('- å½“å‰é¡µ:', doc.page ? 'exists' : 'null');
    console.log('- é¡µé¢å®½åº¦:', doc.page ? doc.page.width : 'unknown');
    console.log('- é¡µé¢é«˜åº¦:', doc.page ? doc.page.height : 'unknown');
    
    console.log('å¼€å§‹ç»˜åˆ¶æ–‡å­—å†…å®¹');
    
    // æµ‹è¯•æœ€åŸºæœ¬çš„æ–‡å­—ç»˜åˆ¶
    try {
      console.log('æµ‹è¯•1: ä½¿ç”¨Helveticaç»˜åˆ¶è‹±æ–‡');
      doc.font('Helvetica')
        .fontSize(20)
        .fillColor('red')
        .text('TEST ENGLISH TEXT', 100, 50);
      
      console.log('æµ‹è¯•2: å°è¯•ç»˜åˆ¶æ•°å­—');
      doc.font('Helvetica')
        .fontSize(16)
        .fillColor('blue')
        .text('123456789', 100, 80);
        
      console.log('æµ‹è¯•3: ç»˜åˆ¶ç®€å•ç¬¦å·');
      doc.font('Helvetica')
        .fontSize(14)
        .fillColor('green')
        .text('!@#$%^&*()', 100, 110);
      
      // æµ‹è¯•ä¸­æ–‡ç»˜åˆ¶
      console.log('æµ‹è¯•4: æµ‹è¯•ä¸­æ–‡æ–‡å­—ç»˜åˆ¶');
      drawTextWithFallback(doc, 'æ•°æ®å¯¼å‡ºæŠ¥å‘Š', 100, 140, fontName, supportsChinese, 18);
      
      console.log('æµ‹è¯•5: æµ‹è¯•æ··åˆæ–‡å­—ç»˜åˆ¶');
      drawTextWithFallback(doc, 'ç”¨æˆ·123 - User Data', 100, 170, fontName, supportsChinese, 14);
      
      console.log('æ‰€æœ‰æ–‡å­—æµ‹è¯•å®Œæˆ');
    } catch (error) {
      console.error('æ–‡å­—ç»˜åˆ¶æµ‹è¯•å¤±è´¥:', error);
    }

    // è¡¨æ ¼é…ç½® - æ·»åŠ åˆ†ç»„åˆ—
    const startX = 50;
    const startY = 100;
    const rowHeight = 40;
    const headers = ['åˆ†ç»„', 'ID', 'å¤´åƒ', 'å§“å', 'é‚®ç®±', 'ç”µè¯', 'åœ°å€', 'çŠ¶æ€'];
    const colWidths = [
      80,  // åˆ†ç»„åˆ—å®½åº¦
      columnWidths.id || 60,
      columnWidths.avatar || 60,
      columnWidths.name || 100,
      columnWidths.email || 150,
      columnWidths.phone || 120,
      columnWidths.address || 200,
      columnWidths.status || 80
    ];
    
    // ç”Ÿæˆåˆ†ç»„ä¿¡æ¯
    const groupInfo = generateGroupInfo(data.length);
    console.log('ç”Ÿæˆåˆ†ç»„ä¿¡æ¯:', groupInfo);

    // è®¡ç®—è¡¨æ ¼æ€»å®½åº¦
    const tableWidth = colWidths.reduce((sum, width) => sum + width, 0);

    // ç°åœ¨å¼€å§‹ç»˜åˆ¶å®Œæ•´çš„è¡¨æ ¼
    console.log('å¼€å§‹ç»˜åˆ¶å®Œæ•´è¡¨æ ¼');
    
    // ç»˜åˆ¶ç¬¬ä¸€é¡µçš„è¡¨å¤´
    let currentY = startY;
    await drawTableHeader(doc, startX, currentY, colWidths, headers, rowHeight, fontName, supportsChinese);
    currentY += rowHeight;
    
    // æ·»åŠ åˆå¹¶å•å…ƒæ ¼æ¼”ç¤ºè¡Œ
    console.log('æ·»åŠ åˆå¹¶å•å…ƒæ ¼æ¼”ç¤º');
    await drawMergedCellDemo(doc, startX, currentY, colWidths, rowHeight, fontName, supportsChinese);
    currentY += rowHeight * 3; // æ¼”ç¤ºå ç”¨3è¡Œ

    // åˆ†æ‰¹å¤„ç†æ•°æ®
    const totalBatches = Math.ceil(data.length / BATCH_SIZE);
    let processedRows = 0;

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const start = batchIndex * BATCH_SIZE;
      const end = Math.min(start + BATCH_SIZE, data.length);
      const batch = data.slice(start, end);

      console.log(`å¤„ç†æ‰¹æ¬¡ ${batchIndex + 1}/${totalBatches}, è¡Œæ•°: ${batch.length}`);

      // æ£€æŸ¥å†…å­˜ä½¿ç”¨
      await checkMemoryUsage();

      for (let rowIndex = 0; rowIndex < batch.length; rowIndex++) {
        const row = batch[rowIndex];

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ–°é¡µ
        if (currentY + rowHeight > doc.page.height - doc.page.margins.bottom) {
          doc.addPage();
          currentY = doc.page.margins.top;
          
          // åœ¨æ–°é¡µé‡ç»˜è¡¨å¤´
          await drawTableHeader(doc, startX, currentY, colWidths, headers, rowHeight, fontName, supportsChinese);
          currentY += rowHeight;
        }

        // ç»˜åˆ¶è¡Œï¼ˆåŒ…å«åˆ†ç»„ä¿¡æ¯ï¼‰
        const currentGroup = groupInfo.find(g => processedRows >= g.startRow && processedRows <= g.endRow);
        const isFirstRowInGroup = currentGroup && processedRows === currentGroup.startRow;
        await drawTableRowWithGroup(doc, row, startX, currentY, colWidths, rowHeight, processedRows, fontName, supportsChinese, currentGroup, isFirstRowInGroup);
        
        currentY += rowHeight;
        processedRows++;

        // æ›´æ–°è¿›åº¦å’Œå†…å­˜æ£€æŸ¥
        if (processedRows % 10 === 0) {
          const progress = Math.round((processedRows / data.length) * 100);
          self.postMessage({
            type: 'progress',
            progress: Math.min(progress, 95)
          });
          
          // é¢‘ç¹æ£€æŸ¥å†…å­˜ä½¿ç”¨å’Œæ¸…ç†ç¼“å­˜
          await checkMemoryUsage();
          clearCacheIfNeeded();
          
          // å®šæœŸæ¸…ç† IndexedDB ç¼“å­˜ï¼ˆæ¯å¤„ç†100è¡Œï¼‰
          if (processedRows % 100 === 0) {
            try {
              const deletedCount = await imageCacheService.cleanupExpiredCache(50);
              if (deletedCount > 0) {
                console.log(`æ¸…ç†äº† ${deletedCount} ä¸ªè¿‡æœŸçš„å›¾ç‰‡ç¼“å­˜`);
              }
            } catch (cleanupError) {
              console.warn('IndexedDBç¼“å­˜æ¸…ç†å¤±è´¥:', cleanupError);
            }
          }
        }
      }

      // æ¸…ç†æ‰¹æ¬¡æ•°æ®
      batch.length = 0;
      
      // ç»™ä¸»çº¿ç¨‹å’ŒGCä¸€äº›æ—¶é—´
      await new Promise(resolve => setTimeout(resolve, 0));
    }

    console.log('æ‰€æœ‰æ•°æ®å¤„ç†å®Œæˆï¼Œç»“æŸæ–‡æ¡£');
    doc.end();

    // æ— éœ€æ¸…ç†å›¾ç‰‡ç¼“å­˜ï¼ˆå·²ç§»é™¤å›¾ç‰‡å¤„ç†ï¼‰
    // æœ€ç»ˆæ¸…ç†
    imageCache.clear();
    defaultAvatarCache.clear();
    
    // æ¸…ç† IndexedDB ç¼“å­˜
    try {
      const deletedCount = await imageCacheService.cleanupExpiredCache();
      console.log(`æœ€ç»ˆæ¸…ç†äº† ${deletedCount} ä¸ªIndexedDBç¼“å­˜æ¡ç›®`);
    } catch (cleanupError) {
      console.warn('æœ€ç»ˆIndexedDBç¼“å­˜æ¸…ç†å¤±è´¥:', cleanupError);
    }
    
    await waitForMemoryCleanup();
    console.log('PDFç”Ÿæˆå®Œæˆï¼Œæ‰€æœ‰ç¼“å­˜å·²æ¸…ç†');

  } catch (error) {
    console.error('PDF ç”Ÿæˆé”™è¯¯:', error);
    // æ— éœ€æ¸…ç†å›¾ç‰‡ç¼“å­˜ï¼ˆå·²ç§»é™¤å›¾ç‰‡å¤„ç†ï¼‰
    throw error;
  }
}
```

#### å†…å­˜æ§åˆ¶
>
> ä¸å¤ªé è°±çš„ apiï¼Œå®é™…ä¸šåŠ¡å½“ä¸­è¿˜æ˜¯é€šè¿‡æµå¼å†™å…¥+å›¾ç‰‡èµ°æŒä¹…åŒ–ç¼“å­˜è§£å†³OOMé—®é¢˜
>

```tsx
// å†…å­˜ç®¡ç†å¸¸é‡
const MEMORY_LIMIT = 500; // MB (è¿›ä¸€æ­¥é™ä½å†…å­˜é™åˆ¶)
const BATCH_SIZE = 200; // æ¯æ‰¹å¤„ç†çš„è¡Œæ•° (æ›´å°çš„æ‰¹å¤„ç†)
const PAGE_ROWS = 25; // æ¯é¡µæ˜¾ç¤ºçš„è¡Œæ•°
const CHUNK_SIZE = 512 * 1024; // 512KB per chunk

// å›¾ç‰‡ç¼“å­˜ï¼ˆé™åˆ¶å¤§å°ä»¥èŠ‚çœå†…å­˜ï¼‰
const imageCache = new Map<string, Buffer | null>();
const defaultAvatarCache = new Map<string, Buffer>();
const MAX_CACHE_SIZE = 200; // é™åˆ¶ç¼“å­˜æœ€å¤§æ¡ç›®æ•°

// ä½¿ç”¨å¯¼å…¥çš„ imageCacheService

// ç­‰å¾…å†…å­˜å›æ”¶
const waitForMemoryCleanup = async () => {
  return new Promise<void>(resolve => {
    // æµè§ˆå™¨ç¯å¢ƒä¸‹æ— æ³•å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼Œä½†å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¼˜åŒ–ï¼š
    // 1. æ¸…ç†ä¸å¿…è¦çš„å¼•ç”¨
    // 2. ç»™æµè§ˆå™¨ä¸€äº›æ—¶é—´è¿›è¡Œè‡ªåŠ¨åƒåœ¾å›æ”¶
    // 3. ä½¿ç”¨ requestIdleCallback åœ¨ç©ºé—²æ—¶æ‰§è¡Œæ¸…ç†
    
    if (typeof requestIdleCallback !== 'undefined') {
      requestIdleCallback(() => resolve(), { timeout: 200 });
    } else {
      // é™çº§åˆ° setTimeout
      setTimeout(resolve, 100);
    }
  });
};

// æ£€æŸ¥å†…å­˜ä½¿ç”¨
const checkMemoryUsage = async () => {
  if ((performance as any).memory) {
    const memoryUsed = (performance as any).memory.usedJSHeapSize / (1024 * 1024);
    if (memoryUsed > MEMORY_LIMIT) {
      console.warn(`å†…å­˜ä½¿ç”¨è¶…è¿‡é™åˆ¶: ${memoryUsed.toFixed(2)}MBï¼Œç­‰å¾…åƒåœ¾å›æ”¶...`);
      await waitForMemoryCleanup();
    }
  }
};
```

#### æµ‹è¯•æ•°æ®

<font style="color:#000000;">10wæ¡æ•°æ®ï¼Œå¯¼å‡ºpdf230mï¼Œè€—æ—¶50sï¼›50wæ¡æ•°æ®ï¼Œå¯¼å‡º pdf1.12Gï¼Œè€—æ—¶5min</font>

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751957459900-a50603db-e0c4-423d-ad09-713f14ac511b.png)

### ä¸‹è½½
>
> æ ¸å¿ƒæ€è·¯ï¼šé€šè¿‡æµè§ˆå™¨æ–‡ä»¶ç³»ç»Ÿï¼Œè·å–æ–‡ä»¶å¥æŸ„ï¼Œæµå¼å†™å…¥
>
> **<font style="color:#DF2A3F;">éš¾ç‚¹ï¼šç›®å‰æ‰€æœ‰çš„ç›¸å…³ç»„ä»¶å‡æ²¡æœ‰å³æ”¯æŒæµå¼å¯¼å‡ºåˆæ”¯æŒæ’å…¥å›¾ç‰‡çš„åŠŸèƒ½ï¼Œæ‰€ä»¥æ ¸å¿ƒæ€è·¯æ˜¯ï¼š</font>**
>
> 1. **<font style="color:#DF2A3F;">åç«¯å¯¼å‡ºï¼Œä½†æ˜¯å¤‡è´§å•åœºæ™¯ä¸é€‚ç”¨</font>**
> 2. **<font style="color:#DF2A3F;">å‰ç«¯å¯¼å‡ºï¼šéœ€è¦æ ¹æ®openxmlåè®®è‡ªå·±å®ç°ä¸€å¥—ï¼Œæµå¼å†™å…¥æ–¹æ¡ˆ</font>**
>

å…³é”®è¯ï¼šwrite-excel-fileã€exceljsã€å†…å­˜æ§åˆ¶ã€åˆ†ç‰‡å¤„ç†

#### æµå¼å¯¼å‡º

```tsx
class StreamExcelWriter {
  private fileHandle: FileSystemFileHandle | null = null;
  private writable: FileSystemWritableFileStream | null = null;
  private encoder = new TextEncoder();
  private zipEntries: Array<{ name: string; data: Uint8Array }> = [];

  async init(filename: string = 'data-export.xlsx'): Promise<boolean> {
    if (!supportsFileSystemAccess()) {
      console.warn('æµè§ˆå™¨ä¸æ”¯æŒFile System Access APIï¼Œå°†ä½¿ç”¨ä¼ ç»Ÿä¸‹è½½æ–¹å¼');
      return false;
    }

    try {
      this.fileHandle = await (window as any).showSaveFilePicker({
        suggestedName: filename,
        types: [{
          description: 'Excel files',
          accept: { 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'] }
        }]
      });
      if (this.fileHandle) {
        this.writable = await this.fileHandle.createWritable();
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.warn('ç”¨æˆ·å–æ¶ˆäº†æ–‡ä»¶ä¿å­˜æˆ–å‘ç”Ÿé”™è¯¯:', error);
      return false;
    }
  }

  addEntry(name: string, content: string | Uint8Array) {
    const data = typeof content === 'string' ? this.encoder.encode(content) : content;
    this.zipEntries.push({ name, data });
  }

  async writeAndClose(): Promise<void> {
    if (!this.writable) {
      throw new Error('æ–‡ä»¶æµæœªåˆå§‹åŒ–');
    }

    // ä½¿ç”¨fflateç”Ÿæˆzipæ•°æ®
    const files: { [key: string]: Uint8Array } = {};
    
    this.zipEntries.forEach(entry => {
      files[entry.name] = entry.data;
    });

    return new Promise((resolve, reject) => {
      zip(files, async (err, data) => {
        if (err) {
          reject(err);
          return;
        }
        
        try {
          const writable = this.writable; // ä¿å­˜å¼•ç”¨é¿å…ç±»å‹æ£€æŸ¥é—®é¢˜
          if (writable) {
            await writable.write(new Uint8Array(data));
            await writable.close();
            this.writable = null;
            resolve();
          } else {
            reject(new Error('æ–‡ä»¶æµå·²å…³é—­'));
          }
        } catch (writeError) {
          reject(writeError);
        }
      });
    });
  }

  async abort() {
    if (this.writable) {
      await this.writable.abort();
      this.writable = null;
    }
  }
}
```

#### åŸºç¡€åè®®demoç¼–å†™

```tsx
 const generateExcelWithStreamWriterOptimized = async (
    writer: StreamExcelWriter,
    dataSource: DataItem[],
    onProgress?: (progress: number, stage: string) => void
  ) => {
    try {
      // ç¬¬ä¸€é˜¶æ®µï¼šç”ŸæˆåŸºç¡€Excelæ–‡ä»¶ç»“æ„
      if (onProgress) onProgress(5, 'æ­£åœ¨åˆ›å»ºåŸºç¡€Excelç»“æ„...');
      
      // åˆ›å»ºåŸºç¡€æ–‡ä»¶ç»“æ„
      writer.addEntry('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>`);
      
      writer.addEntry('xl/workbook.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="æ•°æ®è¡¨" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>`);
      
      if (onProgress) onProgress(15, 'å¼€å§‹æµå¼å†™å…¥å·¥ä½œè¡¨æ•°æ®...');
      
      // æµå¼ç”Ÿæˆå·¥ä½œè¡¨æ•°æ®ï¼ˆçœŸæ­£çš„åˆ†æ‰¹å†™å…¥ï¼‰
      await generateWorksheetStreamly(
        writer,
        dataSource,
        50,
        (current, total) => {
          const progress = 15 + Math.floor((current / total) * 45);
          if (onProgress) onProgress(progress, `æ­£åœ¨æµå¼å†™å…¥Excelæ•°æ®: ${current}/${total} (50è¡Œ/æ‰¹)`);
        }
      );
      
      // åˆ›å»ºå ä½å›¾ï¼ˆ1x1åƒç´ é€æ˜PNGï¼‰
      const placeholderImage = createPlaceholderPngImage();
      writer.addEntry('xl/media/placeholder.png', placeholderImage);
      
      // ç”ŸæˆåŸºç¡€å…³ç³»æ–‡ä»¶ï¼ˆåŒ…å«ç»˜å›¾å…³ç³»ï¼‰
      writer.addEntry('xl/_rels/workbook.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>
</Relationships>`);
      
      // ç”Ÿæˆç»˜å›¾æ–‡ä»¶ï¼ˆä½¿ç”¨å ä½å›¾ï¼‰
      const drawingXml = generateDrawingWithPlaceholders(dataSource.length);
      writer.addEntry('xl/drawings/drawing1.xml', drawingXml);
      
      // ç”Ÿæˆç»˜å›¾å…³ç³»æ–‡ä»¶ï¼ˆæŒ‡å‘å ä½å›¾ï¼‰
      const drawingRels = generateDrawingRelsWithPlaceholders(dataSource.length);
      writer.addEntry('xl/drawings/_rels/drawing1.xml.rels', drawingRels);
      
      // ç”Ÿæˆå·¥ä½œè¡¨å…³ç³»æ–‡ä»¶
      writer.addEntry('xl/worksheets/_rels/sheet1.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing1.xml"/>
</Relationships>`);
      
      // ç”ŸæˆContent_Types.xmlï¼ˆåŒ…å«å›¾ç‰‡æ”¯æŒï¼‰
      writer.addEntry('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
  <Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>
</Types>`);
      
      if (onProgress) onProgress(60, 'åŸºç¡€Excelæ–‡ä»¶å·²ç”Ÿæˆï¼Œè·³è¿‡å›¾ç‰‡å¤„ç†...');
      
      // å¼€å§‹æµå¼æ’å…¥å›¾ç‰‡
      if (onProgress) onProgress(70, 'å¼€å§‹æµå¼æ’å…¥å›¾ç‰‡...');
      
      // æµå¼æ›¿æ¢å ä½å›¾ä¸ºçœŸå®å›¾ç‰‡ï¼ˆ50å¼ ä¸€æ‰¹ï¼ŒçœŸæ­£çš„æµå¼å¤„ç†ï¼‰
      await replaceImagesStreamlyOptimized(writer, dataSource, (current, total) => {
        const progress = 70 + Math.floor((current / total) * 25);
        if (onProgress) onProgress(progress, `æ­£åœ¨æµå¼å¤„ç†å›¾ç‰‡: ${current}/${total} (50å¼ /æ‰¹)`);
      });
      
      if (onProgress) onProgress(95, 'æ­£åœ¨å®Œæˆæ–‡ä»¶å†™å…¥...');
      
      // å†™å…¥å¹¶å…³é—­æ–‡ä»¶
      await writer.writeAndClose();
      
      if (onProgress) onProgress(100, 'å¯¼å‡ºå®Œæˆï¼');
      
    } catch (error) {
      await writer.abort();
      throw error;
    }
  };
```

#### å›¾ç‰‡ç¼“å­˜é€»è¾‘ä¸ pdf ç›¸ä»¿

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751872866709-6d125f7a-79b3-4ff0-a010-2a0bb88e2170.png)

**<font style="color:#DF2A3F;">åœ¨æ²¡æœ‰å›¾ç‰‡çš„æƒ…å†µä¸‹ 65w æ¡å®æµ‹æ•°æ®å¦‚å›¾</font>**

### æ€»ç»“

### é™„å½•

#### file-save

[GitHub - eligrey/FileSaver.js: An HTML5 saveAs() FileSaver implementation](https://github.com/eligrey/FileSaver.js/)

#### streamsaver

[streamsaver](https://www.npmjs.com/package/streamsaver)

#### fflate

[fflate](https://www.npmjs.com/package/fflate)

#### pdfkit

[PDFKit](https://pdfkit.org/)

#### xlsx-populate

[GitHub - dtjohnson/xlsx-populate: Excel XLSX parser/generator written in JavaScript with Node.js and browser support, jQuery/d3-style method chaining, encryption, and a focus on keeping existing workbook features and styles in tact.](https://github.com/dtjohnson/xlsx-populate)

#### sheetjs
>
> sheejs å¯ä»¥æ»¡è¶³åŸºæœ¬åŠŸçš„å¯¼å‡ºï¼Œæ¶‰åŠåˆ°å›¾ç‰‡å¯¼å‡ºåˆ™éœ€è¦é¢å¤–æ”¶è´¹ã€‚$750å·¦å³
>

[SheetJS](https://sheetjs.com/)

#### exceljs

[exceljs](https://www.npmjs.com/package/exceljs)

#### write-excel-file

[write-excel-file](https://www.npmjs.com/package/write-excel-file)

#### vtable
>
> åŸºäº canvas çš„ç™¾ä¸‡çº§æ•°æ®æ¸²æŸ“
>

[VTableä»‹ç»â€”â€”VisActor/VTable æ•™ç¨‹æ–‡æ¡£](https://visactor.com/vtable/guide/introduction)

ä¼˜ç‚¹ï¼šå¯æ¸²æŸ“ä¸Šé™é«˜

ç¼ºç‚¹ï¼šåº•å±‚åŸºäº canvasï¼Œå¯æ‰©å±•æ€§å·®ï¼Œå¯¼å‡ºä¸æ”¯æŒå›¾ç‰‡

#### ali-react-table
>
> åŸºäºä¼ ç»Ÿçš„ table ç»„ä»¶
>

[ali-react-table | ali-react-table](https://ali-react-table.js.org/)

ä¼˜ç‚¹ï¼šå¯æ‰©å±•æ€§é«˜

ç¼ºç‚¹ï¼šå‡ ä¹åœæ­¢è¿­ä»£ï¼Œæ–°åŠŸèƒ½éœ€è¦ fork å¼€å‘
