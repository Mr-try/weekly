### 全局搜索
>
> 需要底层修改第三方虚拟列表代码能够实现
>

#### 快捷键劫持

```tsx
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // 处理 Ctrl+F
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault(); // 阻止默认的浏览器搜索
        setSearchVisible(true);
      }
      // 处理 Escape
      if (e.key === 'Escape') {
        setSearchVisible(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
```

#### 搜索

```tsx
  const findMatches = useCallback((text: string) => {
    if (!text.trim()) {
      setSearchMatches([]);
      setCurrentMatchIndex(0);
      return;
    }

    const matches: Array<{ rowIndex: number; columnKey: string; matchIndex: number }> = [];
    let matchIndex = 0;

    dataSource.forEach((record, rowIndex) => {
      // 搜索ID列
      if (record.id?.toString().toLowerCase().includes(text.toLowerCase())) {
        matches.push({ rowIndex, columnKey: 'id', matchIndex: matchIndex++ });
      }

      // 搜索数据列
      for (let i = 1; i <= 20; i++) {
        const columnKey = `col${i}`;
        const value = (record as any)[columnKey];
        if (value && value.toString().toLowerCase().includes(text.toLowerCase())) {
          matches.push({ rowIndex, columnKey, matchIndex: matchIndex++ });
        }
      }
    });

    console.log(`🔍 搜索"${text}"找到 ${matches.length} 个匹配项:`, matches.map(m => `行${m.rowIndex + 1}:${m.columnKey}`));
    setSearchMatches(matches);
    setCurrentMatchIndex(0);
    
    // 如果找到匹配项，立即滚动到第一个
    if (matches.length > 0) {
      setTimeout(() => {
        scrollToMatch(matches[0]);
      }, 50);
    }
  }, [dataSource, scrollToMatch]);
```

#### 虚拟列表指定行列跳转

```tsx
/**
   * 定位滚动条
   * @desc 优先级按参数顺序降序
   * @param top 目标值
   * @param element 目标元素
   * @param rowKey 行主键
   * @param rowIndex 行索引
   * @param offset 纵向滚动偏移量，用于抵消固定表头
   */
  scrollTo({
    top,
    element,
    rowKey,
    rowIndex,
    offset,
  }: {
    element: HTMLElement
    top: number
    rowKey: string
    rowIndex: number
    offset: number
  }) {
    if (top > -1) return this.scrollToValue(top)
    if (element) return this.scrollToElement(element, offset)
    if (rowKey) return this.scrollToRowKey(rowKey, offset)
    if (rowIndex) return this.scrollToRowIndex(rowIndex, offset)
  }

  /**
   * 定位到指定位置
   * @desc 动态行高时如需精准定位，可以传入目标元素进行二次修正
   * @param top 纵向滚动条位置
   * @param selector 目标元素选择器
   * @param offset 纵向滚动偏移量，用于抵消固定表头
   */
  private scrollToValue(top: number, selector?: string, offset?: number) {
    let view = this.artTableWrapperRef.current
    if (view.clientHeight === view.scrollHeight) {
      view = document.documentElement as HTMLDivElement
    }
    if (!selector) {
      return (view.scrollTop = top)
    }
    const element = view.querySelector(selector)
    // 目标元素真实存在时直接精准定位
    if (element) {
      return this.scrollToElement(element, offset)
    }
    view.scrollTop = top
    // 延迟修正
    setTimeout(() => {
      this.scrollToElement(view.querySelector(selector), offset)
    }, 16)
  }

  /**
   * 定位到指定元素
   * @desc 虚拟表格不应该直接使用该方法
   * @param element
   * @param offset 纵向滚动偏移量，用于抵消固定表头
   */
  private scrollToElement(element: Element, offset?: number) {
    if (!element) return
    let view = this.artTableWrapperRef.current
    if (view.clientHeight === view.scrollHeight) {
      view = document.documentElement as HTMLDivElement
    }
    view.scrollTop = this.getScrollOffsetTop(element, view) + (offset || 0)
  }

  /**
   * 定位到指定行
   * @desc 树形表格有节点展开时不应该使用此方法
   * @param rowIndex 行号（从1开始）
   * @param offset 纵向滚动偏移量，用于抵消固定表头
   */
  private scrollToRowIndex(rowIndex: number, offset?: number) {
    const { cache } = this.rowHeightManager
    const end = Math.min(rowIndex + 1, cache.length)
    let scrollTop = 0
    for (let i = 0; i < end; i++) {
      scrollTop += cache[i]
    }
    this.scrollToValue(scrollTop, `[data-rowindex="${rowIndex}"]`, offset)
  }

  /**
   * 根据primaryKey定位到指定行
   * @desc 支持在树型表格中定位到未展开的节点，调用时应提前更新该节点的所有父节点key至openKeys中，并延迟调用该方法）
   * @param rowKey 行主键
   * @param offset 纵向滚动偏移量，用于抵消固定表头
   */
  private scrollToRowKey(rowKey: string, offset?: number) {
    const { dataSource } = this.props
    const { cache } = this.rowHeightManager
    const length = dataSource.length
    const { primaryKey } = this.props
    let scrollTop = 0
    for (let i = 1; i < length; i++) {
      scrollTop += cache[i]
      if (dataSource[i][primaryKey as string] === rowKey) break
    }
    this.scrollToValue(scrollTop, `#art-table-row-${rowKey}`, offset)
  }

  /**
   * 获取元素在滚动区域中的位置
   * @desc 节选自：https://github.com/Stanko/animated-scroll-to
   * @param element 目标元素
   * @param view 滚动区域元素
   * @private
   */
  private getScrollOffsetTop(element: Element, view: Element): number {
    return this.getElementOffset(element).top - this.getElementOffset(view).top
  }

  private getScrollOffsetLeft(element: Element, view: Element): number {
    return this.getElementOffset(element).left - this.getElementOffset(view).left
  }

  private getElementOffset(element: any) {
    let top = 0
    let left = 0
    do {
      top += element.offsetTop || 0
      left += element.offsetLeft || 0
      element = element.offsetParent
    } while (element)
    return { top, left }
  }

```

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751871907055-525be7e6-3f86-4dae-9eca-7a8bcfdfa679.png)

### 打印
>
> 关键词：pdf、图片缓存、indexDB、web worker、内存限制、分页分段处理等
>
> 注意点：使用 pdfkit 需要考虑字体以及样式（工程量巨大，需要绘制每个数据，demo 只是简单绘制表格部分场景，具体需要根据业务场景自己绘制）
>

#### 指定文件

```tsx
  const fileHandle = await window.showSaveFilePicker({
        suggestedName: `表格导出_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.pdf`,
        types: [{
          description: 'PDF文件',
          accept: {
            'application/pdf': ['.pdf'],
          },
        }],
      });

  // 获取可写流
  writableRef.current = await fileHandle.createWritable();
  
  // 准备列宽配置
  const pageWidth = 750; // A4 横向纸张宽度
  const columnWidths = {
    groupId: pageWidth * 0.08,
    id: pageWidth * 0.05,
    avatar: pageWidth * 0.1,
    name: pageWidth * 0.1,
    email: pageWidth * 0.17,
    phone: pageWidth * 0.15,
    address: pageWidth * 0.25,
    status: pageWidth * 0.1
  };
  
  // 发送数据到 Worker
  workerRef.current?.postMessage({
    type: 'generate',
    data: {
      data: dataSourceRef.current,
      columnWidths,
      pageWidth,
      pageHeight: 550 // A4 横向纸张高度
    }
  });
```

#### indexDB缓存图片

```typescript
/**
 * IndexedDB 图片缓存服务
 * 解决大数据量图片处理的内存问题
 */

export interface CacheItem {
  url: string;
  buffer: ArrayBuffer;
  timestamp: number;
  accessCount: number;
  lastAccess: number;
}

export class ImageCacheService {
  private dbName = 'pdf-image-cache';
  private storeName = 'images';
  private version = 1;
  private db: IDBDatabase | null = null;
  private maxCacheSize = 1000; // 最大缓存条目数
  private maxAge = 24 * 60 * 60 * 1000; // 24小时过期

  /**
   * 初始化数据库连接
   */
  async init(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // 创建对象存储
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'url' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
          store.createIndex('lastAccess', 'lastAccess', { unique: false });
        }
      };
    });
  }

  /**
   * 确保数据库已初始化
   */
  private async ensureDB(): Promise<IDBDatabase> {
    if (!this.db) {
      await this.init();
    }
    return this.db!;
  }

  /**
   * 存储图片到 IndexedDB
   */
  async storeImage(url: string, buffer: Buffer): Promise<void> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);

    // 确保转换为 ArrayBuffer
    let arrayBuffer: ArrayBuffer;
    if (buffer.buffer instanceof ArrayBuffer) {
      arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    } else {
      // 处理 SharedArrayBuffer 的情况
      const uint8Array = new Uint8Array(buffer);
      arrayBuffer = uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);
    }

    const cacheItem: CacheItem = {
      url,
      buffer: arrayBuffer,
      timestamp: Date.now(),
      accessCount: 1,
      lastAccess: Date.now()
    };

    return new Promise((resolve, reject) => {
      const request = store.put(cacheItem);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 从 IndexedDB 获取图片
   */
  async getImage(url: string): Promise<Buffer | null> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);

    return new Promise((resolve, reject) => {
      const request = store.get(url);

      request.onsuccess = () => {
        const result = request.result as CacheItem;
        if (result) {
          // 更新访问统计
          result.accessCount++;
          result.lastAccess = Date.now();
          store.put(result);
          
          // 转换回 Buffer
          const buffer = Buffer.from(result.buffer);
          resolve(buffer);
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 检查图片是否存在于缓存中
   */
  async hasImage(url: string): Promise<boolean> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readonly');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.count(url);
      request.onsuccess = () => resolve(request.result > 0);
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 批量预加载图片
   */
  async preloadBatch(urls: string[]): Promise<void> {
    const loadPromises = urls.map(async (url) => {
      try {
        // 检查是否已缓存
        const exists = await this.hasImage(url);
        if (exists) return;
        
        // 下载并缓存图片
        const response = await fetch(url);
        if (response.ok) {
          const arrayBuffer = await response.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          await this.storeImage(url, buffer);
        }
      } catch (error) {
        console.warn(`预加载图片失败: ${url}`, error);
      }
    });
    
    await Promise.allSettled(loadPromises);
  }

  /**
   * 获取缓存统计信息
   */
  async getCacheStats(): Promise<{ count: number; size: number }> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readonly');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = () => {
        const items = request.result as CacheItem[];
        const count = items.length;
        const size = items.reduce((total, item) => total + item.buffer.byteLength, 0);
        resolve({ count, size });
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 清理过期缓存（LRU策略）
   */
  async cleanupExpiredCache(batchSize: number = 50): Promise<number> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.getAll();
      
      request.onsuccess = async () => {
        const items = request.result as CacheItem[];
        const now = Date.now();
        let deletedCount = 0;
        
        // 找出需要删除的项目
        const toDelete: string[] = [];
        
        // 1. 删除过期项目
        items.forEach(item => {
          if (now - item.timestamp > this.maxAge) {
            toDelete.push(item.url);
          }
        });
        
        // 2. 如果缓存数量超过限制，删除最少使用的项目
        if (items.length > this.maxCacheSize) {
          const sortedItems = items
            .filter(item => !toDelete.includes(item.url))
            .sort((a, b) => {
              // 按最后访问时间和访问次数排序（LRU）
              const scoreA = a.lastAccess + (a.accessCount * 1000);
              const scoreB = b.lastAccess + (b.accessCount * 1000);
              return scoreA - scoreB;
            });
          
          const excessCount = items.length - this.maxCacheSize;
          for (let i = 0; i < Math.min(excessCount, batchSize); i++) {
            toDelete.push(sortedItems[i].url);
          }
        }
        
        // 执行删除
        const deletePromises = toDelete.map(url => {
          return new Promise<void>((resolveDelete) => {
            const deleteRequest = store.delete(url);
            deleteRequest.onsuccess = () => {
              deletedCount++;
              resolveDelete();
            };
            deleteRequest.onerror = () => resolveDelete();
          });
        });
        
        await Promise.all(deletePromises);
        resolve(deletedCount);
      };
      
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 清空所有缓存
   */
  async clearAll(): Promise<void> {
    const db = await this.ensureDB();
    const transaction = db.transaction([this.storeName], 'readwrite');
    const store = transaction.objectStore(this.storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * 关闭数据库连接
   */
  close(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
}

// 单例实例
export const imageCacheService = new ImageCacheService();
```

#### 绘制 pdf 与流式写入

```typescript
// 生成 PDF 的核心逻辑
async function generatePDF(options: PDFGenerationOptions) {
  try {
    console.log('开始生成 PDF...');
    const { data, columnWidths, pageWidth, pageHeight } = options;

    // 初始化图片缓存服务
    try {
      await imageCacheService.init();
      // 清理过期缓存
      await imageCacheService.cleanupExpiredCache();
      console.log('图片缓存服务初始化完成');
    } catch (cacheError) {
      console.warn('图片缓存服务初始化失败，将使用内存缓存:', cacheError);
    }

    // 加载 PDFKit
    await loadPDFKit();

    // 加载字体
    const fontData = await loadFont();

    // 创建 PDF 文档（优化内存使用）
    const doc = new (self as any).PDFDocument({
      size: 'A4',
      layout: 'landscape',
      margins: { top: 50, left: 50, right: 50, bottom: 50 },
      bufferPages: false, // 关闭页面缓存以节省内存
      autoFirstPage: false,
      compress: true, // 启用压缩
      info: {
        Title: '数据导出报告',
        Author: '系统生成',
        Subject: '表格数据导出',
        Keywords: 'PDF,Export,Table',
        CreationDate: new Date()
      }
    });

    // 添加第一页（在字体测试前确保页面存在）
    doc.addPage();
    console.log('添加第一页');

    // 强制等待确保文档准备就绪
    await new Promise(resolve => setTimeout(resolve, 100));

    // 注册并使用思源黑体（支持中文）
    let fontName = 'Helvetica'; // 默认字体
    let supportsChinese = false;

    if (fontData.byteLength > 0) {
      try {
        console.log('注册思源黑体...');
        doc.registerFont('SourceHanSans', fontData);
        fontName = 'SourceHanSans';
        supportsChinese = true;
        console.log('思源黑体注册完成，支持中文显示');

        // 测试字体是否真正可用（确保页面已存在）
        try {
          if (doc.page && doc.page.width) {
            doc.font(fontName).fontSize(12).text('测试中文', 50, 50);
            console.log('中文字体测试成功');
          } else {
            throw new Error('页面未正确初始化');
          }
        } catch (testError) {
          console.warn('中文字体测试失败，回退到默认字体:', testError);
          fontName = 'Helvetica';
          supportsChinese = false;
        }
      } catch (error) {
        console.error('字体注册失败:', error);
        console.warn('将使用默认字体，中文可能显示为乱码');

        // 尝试使用系统中文字体
        const systemFonts = ['SimSun', 'Microsoft YaHei', 'PingFang SC', 'Hiragino Sans GB', 'STHeiti'];
        for (const sysFont of systemFonts) {
          try {
            if (doc.page && doc.page.width) {
              doc.font(sysFont).fontSize(12).text('测试', 50, 50);
              fontName = sysFont;
              supportsChinese = true;
              console.log(`使用系统字体: ${sysFont}`);
              break;
            }
          } catch (sysError) {
            console.warn(`系统字体 ${sysFont} 不可用:`, sysError);
          }
        }
      }
    } else {
      console.warn('思源黑体加载失败，尝试系统字体');

      // 尝试使用系统中文字体
      const systemFonts = ['SimSun', 'Microsoft YaHei', 'PingFang SC', 'Hiragino Sans GB', 'STHeiti', 'Arial Unicode MS'];
      for (const sysFont of systemFonts) {
        try {
          if (doc.page && doc.page.width) {
            doc.font(sysFont).fontSize(12).text('测试', 50, 50);
            fontName = sysFont;
            supportsChinese = true;
            console.log(`使用系统字体: ${sysFont}`);
            break;
          }
        } catch (sysError) {
          console.warn(`系统字体 ${sysFont} 不可用:`, sysError);
        }
      }
    }

    // 收集数据块
    const chunks: Uint8Array[] = [];
    let totalSize = 0;

    doc.on('data', (chunk: Uint8Array) => {
      chunks.push(chunk);
      totalSize += chunk.length;

      if (totalSize >= CHUNK_SIZE) {
        const data = new Uint8Array(Buffer.concat(chunks));
        self.postMessage({
          type: 'progress',
          totalBytes: totalSize,
          chunk: data
        });
        chunks.length = 0;
        totalSize = 0;
      }
    });

    doc.on('end', () => {
      if (chunks.length > 0) {
        const data = new Uint8Array(Buffer.concat(chunks));
        self.postMessage({
          type: 'progress',
          totalBytes: totalSize + data.length,
          chunk: data
        });
      }
      console.log('PDF 生成完成');
      self.postMessage({ type: 'complete' });
    });

    // 检查文档状态
    console.log('检查文档状态:');
    console.log('- 页面数量:', doc.bufferedPageRange ? doc.bufferedPageRange().count : 'unknown');
    console.log('- 当前页:', doc.page ? 'exists' : 'null');
    console.log('- 页面宽度:', doc.page ? doc.page.width : 'unknown');
    console.log('- 页面高度:', doc.page ? doc.page.height : 'unknown');
    
    console.log('开始绘制文字内容');
    
    // 测试最基本的文字绘制
    try {
      console.log('测试1: 使用Helvetica绘制英文');
      doc.font('Helvetica')
        .fontSize(20)
        .fillColor('red')
        .text('TEST ENGLISH TEXT', 100, 50);
      
      console.log('测试2: 尝试绘制数字');
      doc.font('Helvetica')
        .fontSize(16)
        .fillColor('blue')
        .text('123456789', 100, 80);
        
      console.log('测试3: 绘制简单符号');
      doc.font('Helvetica')
        .fontSize(14)
        .fillColor('green')
        .text('!@#$%^&*()', 100, 110);
      
      // 测试中文绘制
      console.log('测试4: 测试中文文字绘制');
      drawTextWithFallback(doc, '数据导出报告', 100, 140, fontName, supportsChinese, 18);
      
      console.log('测试5: 测试混合文字绘制');
      drawTextWithFallback(doc, '用户123 - User Data', 100, 170, fontName, supportsChinese, 14);
      
      console.log('所有文字测试完成');
    } catch (error) {
      console.error('文字绘制测试失败:', error);
    }

    // 表格配置 - 添加分组列
    const startX = 50;
    const startY = 100;
    const rowHeight = 40;
    const headers = ['分组', 'ID', '头像', '姓名', '邮箱', '电话', '地址', '状态'];
    const colWidths = [
      80,  // 分组列宽度
      columnWidths.id || 60,
      columnWidths.avatar || 60,
      columnWidths.name || 100,
      columnWidths.email || 150,
      columnWidths.phone || 120,
      columnWidths.address || 200,
      columnWidths.status || 80
    ];
    
    // 生成分组信息
    const groupInfo = generateGroupInfo(data.length);
    console.log('生成分组信息:', groupInfo);

    // 计算表格总宽度
    const tableWidth = colWidths.reduce((sum, width) => sum + width, 0);

    // 现在开始绘制完整的表格
    console.log('开始绘制完整表格');
    
    // 绘制第一页的表头
    let currentY = startY;
    await drawTableHeader(doc, startX, currentY, colWidths, headers, rowHeight, fontName, supportsChinese);
    currentY += rowHeight;
    
    // 添加合并单元格演示行
    console.log('添加合并单元格演示');
    await drawMergedCellDemo(doc, startX, currentY, colWidths, rowHeight, fontName, supportsChinese);
    currentY += rowHeight * 3; // 演示占用3行

    // 分批处理数据
    const totalBatches = Math.ceil(data.length / BATCH_SIZE);
    let processedRows = 0;

    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const start = batchIndex * BATCH_SIZE;
      const end = Math.min(start + BATCH_SIZE, data.length);
      const batch = data.slice(start, end);

      console.log(`处理批次 ${batchIndex + 1}/${totalBatches}, 行数: ${batch.length}`);

      // 检查内存使用
      await checkMemoryUsage();

      for (let rowIndex = 0; rowIndex < batch.length; rowIndex++) {
        const row = batch[rowIndex];

        // 检查是否需要新页
        if (currentY + rowHeight > doc.page.height - doc.page.margins.bottom) {
          doc.addPage();
          currentY = doc.page.margins.top;
          
          // 在新页重绘表头
          await drawTableHeader(doc, startX, currentY, colWidths, headers, rowHeight, fontName, supportsChinese);
          currentY += rowHeight;
        }

        // 绘制行（包含分组信息）
        const currentGroup = groupInfo.find(g => processedRows >= g.startRow && processedRows <= g.endRow);
        const isFirstRowInGroup = currentGroup && processedRows === currentGroup.startRow;
        await drawTableRowWithGroup(doc, row, startX, currentY, colWidths, rowHeight, processedRows, fontName, supportsChinese, currentGroup, isFirstRowInGroup);
        
        currentY += rowHeight;
        processedRows++;

        // 更新进度和内存检查
        if (processedRows % 10 === 0) {
          const progress = Math.round((processedRows / data.length) * 100);
          self.postMessage({
            type: 'progress',
            progress: Math.min(progress, 95)
          });
          
          // 频繁检查内存使用和清理缓存
          await checkMemoryUsage();
          clearCacheIfNeeded();
          
          // 定期清理 IndexedDB 缓存（每处理100行）
          if (processedRows % 100 === 0) {
            try {
              const deletedCount = await imageCacheService.cleanupExpiredCache(50);
              if (deletedCount > 0) {
                console.log(`清理了 ${deletedCount} 个过期的图片缓存`);
              }
            } catch (cleanupError) {
              console.warn('IndexedDB缓存清理失败:', cleanupError);
            }
          }
        }
      }

      // 清理批次数据
      batch.length = 0;
      
      // 给主线程和GC一些时间
      await new Promise(resolve => setTimeout(resolve, 0));
    }

    console.log('所有数据处理完成，结束文档');
    doc.end();

    // 无需清理图片缓存（已移除图片处理）
    // 最终清理
    imageCache.clear();
    defaultAvatarCache.clear();
    
    // 清理 IndexedDB 缓存
    try {
      const deletedCount = await imageCacheService.cleanupExpiredCache();
      console.log(`最终清理了 ${deletedCount} 个IndexedDB缓存条目`);
    } catch (cleanupError) {
      console.warn('最终IndexedDB缓存清理失败:', cleanupError);
    }
    
    await waitForMemoryCleanup();
    console.log('PDF生成完成，所有缓存已清理');

  } catch (error) {
    console.error('PDF 生成错误:', error);
    // 无需清理图片缓存（已移除图片处理）
    throw error;
  }
}
```

#### 内存控制
>
> 不太靠谱的 api，实际业务当中还是通过流式写入+图片走持久化缓存解决OOM问题
>

```tsx
// 内存管理常量
const MEMORY_LIMIT = 500; // MB (进一步降低内存限制)
const BATCH_SIZE = 200; // 每批处理的行数 (更小的批处理)
const PAGE_ROWS = 25; // 每页显示的行数
const CHUNK_SIZE = 512 * 1024; // 512KB per chunk

// 图片缓存（限制大小以节省内存）
const imageCache = new Map<string, Buffer | null>();
const defaultAvatarCache = new Map<string, Buffer>();
const MAX_CACHE_SIZE = 200; // 限制缓存最大条目数

// 使用导入的 imageCacheService

// 等待内存回收
const waitForMemoryCleanup = async () => {
  return new Promise<void>(resolve => {
    // 浏览器环境下无法强制垃圾回收，但可以通过以下方式优化：
    // 1. 清理不必要的引用
    // 2. 给浏览器一些时间进行自动垃圾回收
    // 3. 使用 requestIdleCallback 在空闲时执行清理
    
    if (typeof requestIdleCallback !== 'undefined') {
      requestIdleCallback(() => resolve(), { timeout: 200 });
    } else {
      // 降级到 setTimeout
      setTimeout(resolve, 100);
    }
  });
};

// 检查内存使用
const checkMemoryUsage = async () => {
  if ((performance as any).memory) {
    const memoryUsed = (performance as any).memory.usedJSHeapSize / (1024 * 1024);
    if (memoryUsed > MEMORY_LIMIT) {
      console.warn(`内存使用超过限制: ${memoryUsed.toFixed(2)}MB，等待垃圾回收...`);
      await waitForMemoryCleanup();
    }
  }
};
```

#### 测试数据

<font style="color:#000000;">10w条数据，导出pdf230m，耗时50s；50w条数据，导出 pdf1.12G，耗时5min</font>

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751957459900-a50603db-e0c4-423d-ad09-713f14ac511b.png)

### 下载
>
> 核心思路：通过浏览器文件系统，获取文件句柄，流式写入
>
> **<font style="color:#DF2A3F;">难点：目前所有的相关组件均没有即支持流式导出又支持插入图片的功能，所以核心思路是：</font>**
>
> 1. **<font style="color:#DF2A3F;">后端导出，但是备货单场景不适用</font>**
> 2. **<font style="color:#DF2A3F;">前端导出：需要根据openxml协议自己实现一套，流式写入方案</font>**
>

关键词：write-excel-file、exceljs、内存控制、分片处理

#### 流式导出

```tsx
class StreamExcelWriter {
  private fileHandle: FileSystemFileHandle | null = null;
  private writable: FileSystemWritableFileStream | null = null;
  private encoder = new TextEncoder();
  private zipEntries: Array<{ name: string; data: Uint8Array }> = [];

  async init(filename: string = 'data-export.xlsx'): Promise<boolean> {
    if (!supportsFileSystemAccess()) {
      console.warn('浏览器不支持File System Access API，将使用传统下载方式');
      return false;
    }

    try {
      this.fileHandle = await (window as any).showSaveFilePicker({
        suggestedName: filename,
        types: [{
          description: 'Excel files',
          accept: { 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'] }
        }]
      });
      if (this.fileHandle) {
        this.writable = await this.fileHandle.createWritable();
        return true;
      } else {
        return false;
      }
    } catch (error) {
      console.warn('用户取消了文件保存或发生错误:', error);
      return false;
    }
  }

  addEntry(name: string, content: string | Uint8Array) {
    const data = typeof content === 'string' ? this.encoder.encode(content) : content;
    this.zipEntries.push({ name, data });
  }

  async writeAndClose(): Promise<void> {
    if (!this.writable) {
      throw new Error('文件流未初始化');
    }

    // 使用fflate生成zip数据
    const files: { [key: string]: Uint8Array } = {};
    
    this.zipEntries.forEach(entry => {
      files[entry.name] = entry.data;
    });

    return new Promise((resolve, reject) => {
      zip(files, async (err, data) => {
        if (err) {
          reject(err);
          return;
        }
        
        try {
          const writable = this.writable; // 保存引用避免类型检查问题
          if (writable) {
            await writable.write(new Uint8Array(data));
            await writable.close();
            this.writable = null;
            resolve();
          } else {
            reject(new Error('文件流已关闭'));
          }
        } catch (writeError) {
          reject(writeError);
        }
      });
    });
  }

  async abort() {
    if (this.writable) {
      await this.writable.abort();
      this.writable = null;
    }
  }
}
```

#### 基础协议demo编写

```tsx
 const generateExcelWithStreamWriterOptimized = async (
    writer: StreamExcelWriter,
    dataSource: DataItem[],
    onProgress?: (progress: number, stage: string) => void
  ) => {
    try {
      // 第一阶段：生成基础Excel文件结构
      if (onProgress) onProgress(5, '正在创建基础Excel结构...');
      
      // 创建基础文件结构
      writer.addEntry('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>`);
      
      writer.addEntry('xl/workbook.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="数据表" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>`);
      
      if (onProgress) onProgress(15, '开始流式写入工作表数据...');
      
      // 流式生成工作表数据（真正的分批写入）
      await generateWorksheetStreamly(
        writer,
        dataSource,
        50,
        (current, total) => {
          const progress = 15 + Math.floor((current / total) * 45);
          if (onProgress) onProgress(progress, `正在流式写入Excel数据: ${current}/${total} (50行/批)`);
        }
      );
      
      // 创建占位图（1x1像素透明PNG）
      const placeholderImage = createPlaceholderPngImage();
      writer.addEntry('xl/media/placeholder.png', placeholderImage);
      
      // 生成基础关系文件（包含绘图关系）
      writer.addEntry('xl/_rels/workbook.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>
</Relationships>`);
      
      // 生成绘图文件（使用占位图）
      const drawingXml = generateDrawingWithPlaceholders(dataSource.length);
      writer.addEntry('xl/drawings/drawing1.xml', drawingXml);
      
      // 生成绘图关系文件（指向占位图）
      const drawingRels = generateDrawingRelsWithPlaceholders(dataSource.length);
      writer.addEntry('xl/drawings/_rels/drawing1.xml.rels', drawingRels);
      
      // 生成工作表关系文件
      writer.addEntry('xl/worksheets/_rels/sheet1.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing1.xml"/>
</Relationships>`);
      
      // 生成Content_Types.xml（包含图片支持）
      writer.addEntry('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
  <Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>
</Types>`);
      
      if (onProgress) onProgress(60, '基础Excel文件已生成，跳过图片处理...');
      
      // 开始流式插入图片
      if (onProgress) onProgress(70, '开始流式插入图片...');
      
      // 流式替换占位图为真实图片（50张一批，真正的流式处理）
      await replaceImagesStreamlyOptimized(writer, dataSource, (current, total) => {
        const progress = 70 + Math.floor((current / total) * 25);
        if (onProgress) onProgress(progress, `正在流式处理图片: ${current}/${total} (50张/批)`);
      });
      
      if (onProgress) onProgress(95, '正在完成文件写入...');
      
      // 写入并关闭文件
      await writer.writeAndClose();
      
      if (onProgress) onProgress(100, '导出完成！');
      
    } catch (error) {
      await writer.abort();
      throw error;
    }
  };
```

#### 图片缓存逻辑与 pdf 相仿

![](https://cdn.nlark.com/yuque/0/2025/png/102344/1751872866709-6d125f7a-79b3-4ff0-a010-2a0bb88e2170.png)

**<font style="color:#DF2A3F;">在没有图片的情况下 65w 条实测数据如图</font>**

### 总结

### 附录

#### file-save

[GitHub - eligrey/FileSaver.js: An HTML5 saveAs() FileSaver implementation](https://github.com/eligrey/FileSaver.js/)

#### streamsaver

[streamsaver](https://www.npmjs.com/package/streamsaver)

#### fflate

[fflate](https://www.npmjs.com/package/fflate)

#### pdfkit

[PDFKit](https://pdfkit.org/)

#### xlsx-populate

[GitHub - dtjohnson/xlsx-populate: Excel XLSX parser/generator written in JavaScript with Node.js and browser support, jQuery/d3-style method chaining, encryption, and a focus on keeping existing workbook features and styles in tact.](https://github.com/dtjohnson/xlsx-populate)

#### sheetjs
>
> sheejs 可以满足基本功的导出，涉及到图片导出则需要额外收费。$750左右
>

[SheetJS](https://sheetjs.com/)

#### exceljs

[exceljs](https://www.npmjs.com/package/exceljs)

#### write-excel-file

[write-excel-file](https://www.npmjs.com/package/write-excel-file)

#### vtable
>
> 基于 canvas 的百万级数据渲染
>

[VTable介绍——VisActor/VTable 教程文档](https://visactor.com/vtable/guide/introduction)

优点：可渲染上限高

缺点：底层基于 canvas，可扩展性差，导出不支持图片

#### ali-react-table
>
> 基于传统的 table 组件
>

[ali-react-table | ali-react-table](https://ali-react-table.js.org/)

优点：可扩展性高

缺点：几乎停止迭代，新功能需要 fork 开发
